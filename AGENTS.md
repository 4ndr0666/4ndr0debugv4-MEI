# File: AGENTS.md — 4ndr0debugv4‑MEI Repository Agent Guide

## Purpose  
This file defines project‑level instructions, coding conventions, workflows, and mandatory checks for any AI agent (e.g. Codex) operating on this repo. It ensures consistency, avoids regressions, preserves feature set, and enforces quality, structure, and safety standards.

---

## 1. Project Overview & Structure  

- This is a Vite + React + TypeScript application, structured roughly as:

```
/ (root)
  ├── src (implicit root for TS/JS/TSX files)
  │     ├── index.tsx
  │     ├── App.tsx
  │     ├── AppContext.tsx
  │     ├── constants.ts, types.ts, utils.ts, services.ts, arsenal.ts, language-guidelines.ts, metadata.json …
  │     ├── contexts/ (PersistenceContext.tsx, SessionContext.tsx)
  │     └── Components/ (many *.tsx React components, modals, editors, UI controls, etc.)
  ├── index.html
  ├── vite.config.ts
  ├── package.json, tsconfig.json
  └── other root‑level docs (README.md, CHANGELOG.md, etc.)
```

- Agents should treat **all `.tsx`, `.ts`, `.js`, `.json` files under root (except node_modules or build output)** as potential editing targets — but modifications must maintain existing functionality, handle edge‑cases, and include necessary imports/types.

- **Do not remove or disable** any existing component, utility, context, service, or logic without explicit confirmation that it is redundant (after silent “superset check”).  

- All generated code must integrate seamlessly with existing architecture: contexts, props naming, type annotations, import paths, and existing state flows.

---

## 2. Coding Conventions  

When generating or modifying code:

- Use **TypeScript** (.tsx / .ts) with existing `tsconfig.json` rules.  
- Use **functional React components + hooks**, consistent with existing style.  
- Preserve existing naming style: PascalCase for component filenames, camelCase for variables/functions, UPPER_SNAKE or const-cap style for constants as in existing files.  
- Use consistent import ordering and file-relative import paths (do not introduce absolute or alias-based paths unless already configured).  
- Maintain strict typing — do not use `any` unless absolutely unavoidable; prefer explicit interfaces/types defined in `types.ts`.  
- Do not introduce any external dependencies beyond those declared in `package.json` (unless explicitly authorized).  

---

## 3. Build / Testing / Quality Checks  

Before committing any change, the agent must run and verify:

```
npm install
npm run type-check     # or `tsc --noEmit` if configured
npm run lint           # if linting is configured
npm run build          # via Vite: production build to catch build-time errors
```

If code fails type-check, lint, or build, the change must be reverted or revised.  

If tests exist or are added: run `npm test` (or configured test command) and ensure **all tests pass**.  

No PR or commit generated by an agent should be merged without passing build, type-check, lint, and test suites.  

---

## 4. Refactoring & Optimization Directives  

Agents are authorized to perform the following transformations — but must do so under strict “superset check” policy (see Section 5):

- **Code‑splitting / dynamic imports**: convert heavy or rarely used components (e.g. modals, editors, diff viewers, history panels, large UI subtrees) to lazy-loaded modules via `React.lazy()` + `Suspense`.  
- **Dead code elimination**: identify and safely remove imports, variables, functions, components, or files that are truly unreachable or unused — only after verifying no runtime references.  
- **Refactor imports for tree‑shaking**: where large libraries are used (e.g. utility libraries), switch to per-function imports (e.g. `import debounce from 'lodash/debounce'`) to reduce bundle size.  
- **Bundle configuration tuning**: update `vite.config.ts` as needed (e.g. build target, disabling sourcemaps, manual chunking) — but only if verified that it does not break build or dev workflow.  
- **Performance optimizations in React runtime**: add `React.memo`, `useMemo`, `useCallback`, list virtualization for large lists — but only after confirming correctness and UI behavior remains unchanged.  
- **Documentation updates**: when refactors change structure, update inline comments or minimal docblocks to reflect logic; ensure no stubs or placeholders remain.  

---

## 5. Superset‑Check & Regression Policy (CRITICAL)  

> **You are REQUIRED to conduct a silent, internal “superset check” against the previous stable version’s feature set.**  

- Before making any change, the agent must produce a complete inventory of features/components/modules/tests currently present.  
- After change, it must validate that **all** previously existing features still compile, build, render (if UI), and pass any tests.  
- Loss or weakening of any prior functionality counts as a **CRITICAL FAILURE** — the agent must revert or explicitly raise a conflict for human confirmation.  
- No silent removals of components, code paths, utilities, or test cases permitted without explicit confirmation protocol.  

---

## 6. Responsibility toward Completeness & Quality  

- All components, utilities, contexts, services — both “core” and “auxiliary” — must remain integrated in the codebase. No incomplete logic, commented-out placeholders (`// TODO`), or orphaned references should remain.  
- If an existing feature lacks proper tests or type coverage, the agent should add minimal tests or type definitions before modifying — or flag it for manual review.  
- Error handling, edge cases, fallback UI, and previous bug fixes must be preserved exactly as before.  

---

## 7. Pull Request / Commit Guidelines (when submitting agent-generated changes)  

When generating a PR:

1. Provide a clear description of what was changed and why (e.g. “refactor: lazy-load modal components & code-split heavy UI components to improve initial load performance”).  
2. List all affected modules/components.  
3. Reference related issues or tasks (if any).  
4. Show summary of tests / build results (build logs, type-check pass, lint pass).  
5. For UI changes: include screenshots if user-facing; verify behavior manually or via test scenarios.  
6. Keep PR scoped to a single concern (e.g. “code splitting & bundle optimization” or “dependency import refactor”), to ease review and minimize risk.  

---

## 8. Limitations & Safeguards  

- Agents should **not introduce** new large dependencies or external tools/libraries without explicit human approval.  
- Modules for styling, assets, or build infrastructure should only be changed if necessary and safe; avoid over‑engineering.  
- Any refactor touching core logic (state management, contexts, key UI flows) must be minimal and do not alter observable behavior unless bug‑fix or explicit feature improvement.  
- Agents must preserve code readability, maintain existing conventions, and avoid hacky shortcuts that degrade maintainability.  

---

## 9. Agent Workflow Recommendation  

When starting a refactor or optimization effort:

1. **Plan step**: generate a high‑level plan describing which parts of codebase will be changed (lazy-loading, chunking, import refactor, etc.), and how you will verify regressions.  
2. **Inventory step**: produce full feature/module test/usage list.  
3. **Act step**: apply changes iteratively, module by module.  
4. **Validate step**: run build, type-check, tests, optionally manual UI smoke test.  
5. **Document step**: update code comments, minimal docs if needed, and annotate PR with rationale.  
6. **Reflect step**: produce summary of improvements (bundle size reduction, code organization gains), and note any tradeoffs or follow-up tasks.  

---

## 10. Code Style & Contributing Conventions  

- Use TypeScript 4.x (as configured).  
- Follow existing lint / formatting rules (if present) — avoid introducing prettier/formatter config changes unless explicitly required.  
- Keep files small and focused: one React component per file (PascalCase), one hook/util per file (camelCase).  
- Add JSDoc-style comments for non-trivial logic or public interfaces (especially in services, utils, context providers).  
- Use relative imports; prefer explicit module paths over index barrels if barrels introduce ambiguity.  

---

## 11. Summary  

This Agents.md is the canonical source-of-truth for any AI agent operating on this repo. It enforces:

- **No regressions** (superset‑check policy).  
- **Complete integration** (no orphaned code, no stubs, full error-handling).  
- **Code quality, readability, performance** and adherence to project conventions.  

Any agent that does not follow these rules or produces code violating them must be rejected or corrected.  
